<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Prometheus ZIO Wrapper · ZIO Metrics</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="ZIO Metrics Prometheus provides Prometheus&#x27; 4 metrics plus a number of"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Prometheus ZIO Wrapper · ZIO Metrics"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.github.io/zio-metrics/"/><meta property="og:description" content="ZIO Metrics Prometheus provides Prometheus&#x27; 4 metrics plus a number of"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/zio-metrics/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/zio-metrics/js/scrollSpy.js"></script><link rel="stylesheet" href="/zio-metrics/css/main.css"/><script src="/zio-metrics/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zio-metrics/"><img class="logo" src="/zio-metrics/img/navbar_brand2x.png" alt="ZIO Metrics"/><h2 class="headerTitleWithLogo">ZIO Metrics</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/zio-metrics/docs/essentials/essentials_index" target="_self">Documentation</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Prometheus ZIO Wrapper</h1></header><article><div><span><p>ZIO Metrics Prometheus provides Prometheus' 4 metrics plus a number of
exporters all connected through the <code>CollectorRegistry</code>.</p>
<p>Required imports for presented snippets:</p>
<pre><code class="hljs css language-scala mdoc:silent"><span class="hljs-keyword">import</span> zio.{ <span class="hljs-type">RIO</span>, <span class="hljs-type">Runtime</span> }
<span class="hljs-keyword">import</span> io.prometheus.client.<span class="hljs-type">CollectorRegistry</span>
<span class="hljs-keyword">import</span> zio.metrics.{ <span class="hljs-type">Label</span> =&gt; <span class="hljs-type">ZLabel</span>}
<span class="hljs-keyword">import</span> zio.metrics.prometheus._
<span class="hljs-keyword">import</span> zio.metrics.prometheus.helpers._
<span class="hljs-keyword">import</span> zio.metrics.prometheus.exporters._

<span class="hljs-comment">// also for printing debug messages to the console</span>
<span class="hljs-keyword">import</span> zio.console.{ <span class="hljs-type">Console</span>, putStrLn }
<span class="hljs-comment">// and for sleeping/clocks</span>
<span class="hljs-keyword">import</span> zio.clock.<span class="hljs-type">Clock</span>
<span class="hljs-keyword">import</span> zio.duration.<span class="hljs-type">Duration</span>
<span class="hljs-keyword">import</span> scala.concurrent.duration._
<span class="hljs-comment">// and for inspecting prometheus</span>
<span class="hljs-keyword">import</span> java.util
</code></pre>
<p>We will also provide our own <code>Runtime</code>:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> rt = <span class="hljs-type">Runtime</span>
    .unsafeFromLayer(<span class="hljs-type">Registry</span>.live ++ <span class="hljs-type">Exporters</span>.live ++ <span class="hljs-type">Console</span>.live ++ <span class="hljs-type">Clock</span>.live)
</code></pre>
<p>We include ALL 5 metrics in the <code>runtime</code> since we will see examples for each, normally you
just need to include the ones you will actually use.</p>
<p>We will assume the reader has working knowledge for Prometheus already, if
not then head over to <a href="https://github.com/prometheus/client_java">Prometheus Java Client</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="registry"></a><a href="#registry" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Registry</h2>
<p>All metrics register themselves with the registry and all exporters need access
to the registry in order to obtain and export its registered metrics.
ZIO-Metrics expose it via <a href="https://zio.dev/docs/datatypes/datatypes_ref">Ref</a>
providing methods to register every metric type plus one <code>getCurrent</code> method to
obtain the current <code>CollectorRegistry</code></p>
<p>You can access the registry module using either environmental effects or
zio-metrics
<a href="https://github.com/zio/zio-metrics/blob/master/prometheus/src/main/scala/zio/metrics/prometheus/Helpers.scala">Helper</a>
methods. We'll start using environmental effects until the <code>Helper</code> methods are introduced:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testRegistry: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    pr &lt;- <span class="hljs-type">RIO</span>.environment[<span class="hljs-type">Registry</span>]
    _  &lt;- pr.get.registerCounter(<span class="hljs-type">ZLabel</span>(<span class="hljs-string">"simple_counter"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"method"</span>), <span class="hljs-string">"Just a simple counter for your consideration"</span>))
    r  &lt;- pr.get.getCurrent()
  } <span class="hljs-keyword">yield</span> r
</code></pre>
<p>All <code>register*</code> methods in <code>Registry</code> require a <code>Label</code> object  (some
may require more parameters). A label is composed of a name and an array of
labels which may be empty in the case where no labels are required.</p>
<pre><code class="hljs css language-scala mdoc:silent"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Label</span>[<span class="hljs-type">A</span>](<span class="hljs-params">name: <span class="hljs-type">A</span>, labels: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]</span>)</span>
</code></pre>
<p>Note that zio-metrics does not depend on either cats or scalaz so this Show is
defined on <code>typeclasses</code> with instances for <code>String</code> and <code>Class[A]</code>.
Besides the <code>register*</code> functions, we also have <code>getCurrent()</code> that simply
returns the <code>CollectorRegistry</code> which is needed by all <code>Exporters</code>.</p>
<p>Using the registry helper the above function becomes:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testRegistryHelper: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    _  &lt;- registerCounter(<span class="hljs-string">"simple_counter"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"method"</span>))
    r  &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> r
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="pass-the-collectorregistry-explicitly"></a><a href="#pass-the-collectorregistry-explicitly" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pass the CollectorRegistry explicitly</h3>
<p>If, for whatever reason, you already have a <code>CollectorRegistry</code> in your app and
want to pass that to <code>zio-metrics-prometheus</code>, you can use the <code>explicit</code> layer
intead of <code>live</code>. You just need to feed an <code>Option[CollectorRegistry]</code> to the
<code>explicit</code> layer so:</p>
<pre><code class="hljs css language-scala"> <span class="hljs-keyword">val</span> myRegistry = <span class="hljs-type">CollectorRegistry</span>.defaultRegistry
  <span class="hljs-keyword">val</span> preCounter = <span class="hljs-type">PCounter</span>
    .build()
    .name(<span class="hljs-string">"PreExistingCounter"</span>)
    .help(<span class="hljs-string">"Counter configured before using zio-metrics"</span>)
    .register(myRegistry)
  preCounter.inc(<span class="hljs-number">9</span>)

  <span class="hljs-keyword">val</span> myCustomLayer = <span class="hljs-type">ZLayer</span>.succeed[<span class="hljs-type">Option</span>[<span class="hljs-type">CollectorRegistry</span>]](<span class="hljs-type">Some</span>(myRegistry)) &gt;&gt;&gt; <span class="hljs-type">Registry</span>.explicit
</code></pre>
<p>In this example we create a <code>CollectorRegistry</code> external to <code>zio-metrics</code>
(<code>myRegistry</code>), add a counter and increase it to 9. The next step is to <code>lift</code>
<code>myRegistry</code> to a layer (i.e. create a Layer that takes <code>Nothing</code> and outputs
<code>Option[CollectorRegistry]</code>) and compose it with <code>Registry.explicit</code>. The you
just need to use <code>myCustomLayer</code> wherever you would have used <code>Registry.live</code>,
i.e. <code>counter.register(name, Array(&quot;exporter&quot;)).provideLayer(myCustomLayer)</code> or <code>val rt = Runtime.unsafeFromLayer(myCustomLayer ++ Exporters.live ++ Console.live)</code></p>
<h2><a class="anchor" aria-hidden="true" id="counter"></a><a href="#counter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Counter</h2>
<p>Counter has methods to increase a counter by 1 or by an arbitrary double
passed as a parameter along with optional labels.</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testCounter: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    c &lt;- <span class="hljs-type">Counter</span>(<span class="hljs-string">"simple_counter"</span>, <span class="hljs-type">Array</span>.empty[<span class="hljs-type">String</span>])
    _ &lt;- c.inc()
    _ &lt;- c.inc(<span class="hljs-number">2.0</span>)
    r &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> r
</code></pre>
<p>If the counter is registered with labels, then you need to increase the counter
passing the same number of labels when registered.</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testLabeledCounter: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    c  &lt;- <span class="hljs-type">Counter</span>(<span class="hljs-string">"simple_counter_labeled"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"method"</span>, <span class="hljs-string">"resource"</span>))
    _  &lt;- c.inc(<span class="hljs-type">Array</span>(<span class="hljs-string">"get"</span>, <span class="hljs-string">"users"</span>))
    _  &lt;- c.inc(<span class="hljs-number">2.0</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"get"</span>, <span class="hljs-string">"users"</span>))
    r  &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> r
</code></pre>
<p>You can run and verify the results so:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> timeSeriesNames = <span class="hljs-keyword">new</span> util.<span class="hljs-type">HashSet</span>[<span class="hljs-type">String</span>]() {
    add(<span class="hljs-string">"simple_counter_total"</span>)
  }
  <span class="hljs-keyword">val</span> r = rt.unsafeRun(testCounter)
  <span class="hljs-keyword">val</span> count = r
    .filteredMetricFamilySamples(timeSeriesNames)
    .nextElement()
    .samples
    .get(<span class="hljs-number">0</span>)
    .value
  assert(count == <span class="hljs-number">3.0</span>)
</code></pre>
<p>Note: starting with Prometheus Java client v0.10 (a dependency of this lib),
all Counter samples now must have a &quot;_total&quot; suffix. Without the suffix,
the above code snippet will fail with a java.util.NoSuchElementException
because no matching name will be found.
(See v0.10.0 release note for details: <a href="https://github.com/prometheus/client_java/releases/tag/parent-0.10.0">https://github.com/prometheus/client_java/releases/tag/parent-0.10.0</a>)</p>
<p>There's an easier way to observe the state of the <code>CollectorRegistry</code> using the
<code>write004</code> Exporter covered later.</p>
<h2><a class="anchor" aria-hidden="true" id="helpers"></a><a href="#helpers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Helpers</h2>
<p>Environmental effects gives us access direct access to zio-metrics' <code>Metrics</code>
which means we have to pass empty arrays and other <code>Default</code> parameters when
we do not use any labels or special configuration. Helper methods take care of all the boilerplate
and gives us easy-to-use functions. Using them out <code>testCounter</code> example above
becomes:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testCounterHelper: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    c &lt;- counter.register(<span class="hljs-string">"PrometheusTestHelper"</span>)
    _ &lt;- c.inc()
    _ &lt;- c.inc(<span class="hljs-number">2.0</span>)
    r &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> r
</code></pre>
<p>This version accepts directly either a <code>String</code> for a name, the
helper method creates the empty array the labels parameter needs. There are also
helper methods that supports an array for labels:</p>
<pre><code class="hljs">    c &lt;- counter.<span class="hljs-keyword">register</span>(<span class="hljs-string">"PrometheusTestHelper"</span>, <span class="hljs-keyword">Array</span>(<span class="hljs-string">"method"</span>, <span class="hljs-string">"resource"</span>))
</code></pre>
<p>From here on, we will use environmental effects, helper methods, or a mix of both.</p>
<h2><a class="anchor" aria-hidden="true" id="gauge"></a><a href="#gauge" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gauge</h2>
<p>Besides increasing, a gauge may also decrease and has methods to <code>set</code> and <code>get</code>
values as well as to <code>setToTime</code> and <code>setToCurrentTime</code>.</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testGauge: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, (<span class="hljs-type">CollectorRegistry</span>, <span class="hljs-type">Double</span>)] = <span class="hljs-keyword">for</span> {
    g  &lt;- gauge.register(<span class="hljs-string">"simple_gauge"</span>)
    _  &lt;- g.inc()
    _  &lt;- g.inc(<span class="hljs-number">2.0</span>)
    _  &lt;- g.dec(<span class="hljs-number">1.0</span>)
    d  &lt;- g.getValue()
    r  &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> (r, d)
</code></pre>
<p>Here I chose to return both the <code>CollectorRegistry</code> and the latest value from
the gauge as a tuple. <code>gauge</code> refers to the <a href="https://github.com/zio/zio-metrics/blob/master/prometheus/src/main/scala/zio/metrics/prometheus/Helpers.scala">helper
method</a>.</p>
<p>With labels it looks like this:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testLabeledGauge: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, (<span class="hljs-type">CollectorRegistry</span>, <span class="hljs-type">Double</span>)] = <span class="hljs-keyword">for</span> {
    g  &lt;- <span class="hljs-type">Gauge</span>(<span class="hljs-string">"simple_gauge"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"method"</span>))
    _  &lt;- g.inc(<span class="hljs-type">Array</span>(<span class="hljs-string">"get"</span>))
    _  &lt;- g.inc(<span class="hljs-number">2.0</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"get"</span>))
    _  &lt;- g.dec(<span class="hljs-number">1.0</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"get"</span>))
    d  &lt;- g.getValue(<span class="hljs-type">Array</span>(<span class="hljs-string">"get"</span>))
    r  &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> (r, d)
</code></pre>
<p>And to run and verify the result:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> setG: util.<span class="hljs-type">Set</span>[<span class="hljs-type">String</span>] = <span class="hljs-keyword">new</span> util.<span class="hljs-type">HashSet</span>[<span class="hljs-type">String</span>]()
  setG.add(<span class="hljs-string">"simple_gauge"</span>)
  <span class="hljs-keyword">val</span> rG = rt.unsafeRun(testGauge)
  <span class="hljs-keyword">val</span> a1 = rG._1
    .filteredMetricFamilySamples(setG)
    .nextElement()
    .samples
    .get(<span class="hljs-number">0</span>)
    .value

  assert(a1 == rG._2)
  assert(a1 == <span class="hljs-number">2.0</span>)
</code></pre>
<p>This way to verify our metrics is awkward and cumbersome, let's look at what
<code>Exporters</code> can do for us in this regard.</p>
<h2><a class="anchor" aria-hidden="true" id="exporters"></a><a href="#exporters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Exporters</h2>
<p>Prometheus provides 4 main exporters:</p>
<ol>
<li>Http</li>
<li>Pushgateways</li>
<li>Graphite Bridges</li>
<li>TextFormat</li>
<li>DefaultExports</li>
</ol>
<p>TextFormat is a Prometheus Exporter with a single method <code>write004</code> which writes the
contents of a <code>CollectorRegistry</code> in the 004 content-type encoding that
Prometheus expects. That's what we will use to verify our metrics from now on.</p>
<p>DefaultExports, on the other hand, registers a number of HotSpot collectors to a
given registry. Let's look at an example of how all this works.</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">import</span> io.prometheus.client.exporter.<span class="hljs-type">HTTPServer</span>
  
  <span class="hljs-keyword">val</span> exporterTest: <span class="hljs-type">RIO</span>[
    <span class="hljs-type">Registry</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Exporters</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Console</span>,
    <span class="hljs-type">HTTPServer</span>
  ] =
    <span class="hljs-keyword">for</span> {
      r  &lt;- getCurrentRegistry()
      _  &lt;- initializeDefaultExports(r)
      hs &lt;- http(r, <span class="hljs-number">9090</span>)
      c  &lt;- <span class="hljs-type">Counter</span>(<span class="hljs-string">"ExportersTest"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"exporter"</span>))
      _  &lt;- c.inc(<span class="hljs-type">Array</span>(<span class="hljs-string">"counter"</span>))
      _  &lt;- c.inc(<span class="hljs-number">2.0</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"counter"</span>))
      h  &lt;- histogram.register(<span class="hljs-string">"export_histogram"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"exporter"</span>, <span class="hljs-string">"method"</span>))
      _  &lt;- h.time(() =&gt; <span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">2000</span>), <span class="hljs-type">Array</span>(<span class="hljs-string">"histogram"</span>, <span class="hljs-string">"get"</span>))
      s  &lt;- write004(r)
      _  &lt;- putStrLn(s)
    } <span class="hljs-keyword">yield</span> hs

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> =
    rt.unsafeRun(exporterTest &gt;&gt;= (server =&gt; putStrLn(<span class="hljs-string">s"Server port: <span class="hljs-subst">${server.getPort()}</span>"</span>)))
</code></pre>
<p>Where <code>&gt;&gt;=</code> = <code>flatMap</code>. Also note that <code>exporters</code> refers to the helper object
and that in this example we are returning the <code>HTTPServer</code> object used by
Prometheus, we could potentially use it (for instance) to stop the
server,<code>exporters</code> helper has the method <code>stopHttp</code> for that.
Besides printing the metrics to the console you can also ask them via http <code>curl http://localhost:9090</code>. Since we are already using <code>histogram</code> in this example,
let's look at it in more detail next.</p>
<h2><a class="anchor" aria-hidden="true" id="histogram"></a><a href="#histogram" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Histogram</h2>
<p>Histogram has 4 modes we can use:</p>
<ol>
<li>We can <code>time</code> how long a function takes to complete.</li>
<li>We can <code>observe</code> arbitrary <code>Double</code> values.</li>
<li>We can start an arbitrary <code>timer</code> and <code>observe</code> its duration.</li>
<li>We can <code>time</code> how long a <code>zio.Task</code> or a <code>zio.RIO</code> takes to complete.</li>
</ol>
<p>Using a histogram to <code>time</code> a function is pretty much what was shown on the
<code>Exporters</code> example above, where <code>() =&gt; Thread.sleep(2000)</code> is the function we
want to time:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testHistogramTimer: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    h &lt;- histogram.register(<span class="hljs-string">"simple_histogram_timer"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"method"</span>))
    _ &lt;- h.time(() =&gt; <span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">2000</span>), <span class="hljs-type">Array</span>(<span class="hljs-string">"post"</span>))
    r &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> r
</code></pre>
<p>You can also configure the <a href="https://prometheus.github.io/client_java/io/prometheus/client/Histogram.Builder.html#buckets-double">different types of
buckets</a>
, for instance, we can use <code>Linear Buckets</code> with the function above:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testHistogramTimerHelper: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    h &lt;- <span class="hljs-type">Histogram</span>(<span class="hljs-string">"simple_histogram_time_custom"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"method"</span>), <span class="hljs-type">LinearBuckets</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>))
    _ &lt;- h.time(() =&gt; <span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">2000</span>), <span class="hljs-type">Array</span>(<span class="hljs-string">"post"</span>))
    r &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> r
</code></pre>
<p>You can, of course, verify the usual way:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> setHT: util.<span class="hljs-type">Set</span>[<span class="hljs-type">String</span>] = <span class="hljs-keyword">new</span> util.<span class="hljs-type">HashSet</span>[<span class="hljs-type">String</span>]()
  setHT.add(<span class="hljs-string">"simple_histogram_timer_count"</span>)
  setHT.add(<span class="hljs-string">"simple_histogram_timer_sum"</span>)

  <span class="hljs-keyword">val</span> rht   = rt.unsafeRun(testHistogramTimer)
  <span class="hljs-keyword">val</span> cnt   = rht.filteredMetricFamilySamples(setHT).nextElement().samples.get(<span class="hljs-number">0</span>).value
  <span class="hljs-keyword">val</span> sum   = rht.filteredMetricFamilySamples(setHT).nextElement().samples.get(<span class="hljs-number">1</span>).value
</code></pre>
<p>or simpler using our <code>exporters</code> helper:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> rhtE = rt.unsafeRun(testHistogramTimerHelper)
  write004(rhtE)
</code></pre>
<p>If, instead, we want to measure arbitrary values:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testHistogram: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    h &lt;- histogram.register(<span class="hljs-string">"simple_histogram"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"method"</span>))
    _ &lt;- <span class="hljs-type">RIO</span>.foreach(<span class="hljs-type">List</span>(<span class="hljs-number">10.5</span>, <span class="hljs-number">25.0</span>, <span class="hljs-number">50.7</span>, <span class="hljs-number">57.3</span>, <span class="hljs-number">19.8</span>))(h.observe(_, <span class="hljs-type">Array</span>(<span class="hljs-string">"get"</span>)))
    r &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> r
</code></pre>
<p><code>RIO.foreach</code> will take each value of the list <code>List(10.5, 25.0, 50.7, 57.3, 19.8)</code> and apply the function <code>h.observe(_, Array(&quot;get&quot;))</code> to each
value in a synchronous manner, where <code>_</code> refers to the value (10.5, 25.0,
etc.) and <code>Array(&quot;get&quot;)</code> is the specific label for the current observation.</p>
<p>We can override the <code>DefaultBuckets</code> so:</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testHistogramBuckets: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    h &lt;- histogram.register(<span class="hljs-string">"simple_histogram"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"method"</span>), <span class="hljs-type">DefaultBuckets</span>(<span class="hljs-type">Seq</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>)))
    _ &lt;- <span class="hljs-type">RIO</span>.foreach(<span class="hljs-type">List</span>(<span class="hljs-number">10.5</span>, <span class="hljs-number">25.0</span>, <span class="hljs-number">50.7</span>, <span class="hljs-number">57.3</span>, <span class="hljs-number">19.8</span>))(h.observe(_, <span class="hljs-type">Array</span>(<span class="hljs-string">"get"</span>)))
    r &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> r
</code></pre>
<p>To use an arbitrary timer, after registering the histogram, we need to
start the timer using our recently created <code>histogram</code> object with the
<code>startTimer</code> method which returns a <code>timer</code> object. We will use this <code>timer</code> to
mark every point we want observed (measure) thus giving us the duration between
when <code>startTimer</code> was called and each time we <code>observeDuration</code>.</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> f = (n: <span class="hljs-type">Long</span>) =&gt; {
    <span class="hljs-type">RIO</span>.sleep(<span class="hljs-type">Duration</span>.fromScala(n.millis)) *&gt; putStrLn(<span class="hljs-string">s"n = <span class="hljs-subst">$n</span>"</span>)
  }

  <span class="hljs-keyword">val</span> testHistogramDuration: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Console</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Clock</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    h &lt;- <span class="hljs-type">Histogram</span>(<span class="hljs-string">"duration_histogram"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"method"</span>), <span class="hljs-type">ExponentialBuckets</span>(<span class="hljs-number">0.25</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>))
    t &lt;- h.startTimer(<span class="hljs-type">Array</span>(<span class="hljs-string">"time"</span>))
    dl &lt;- <span class="hljs-type">RIO</span>.foreach(<span class="hljs-type">List</span>(<span class="hljs-number">75</span>L, <span class="hljs-number">750</span>L, <span class="hljs-number">2000</span>L))(
           n =&gt;
             <span class="hljs-keyword">for</span> {
               _ &lt;- f(n)
               d &lt;- h.observeDuration(t)
             } <span class="hljs-keyword">yield</span> d
         )
    _ &lt;- <span class="hljs-type">RIO</span>.foreach(dl)(d =&gt; putStrLn(d.toString()))
    r &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> r
</code></pre>
<p>We could define <code>ExponentialBuckets</code> substituting the following line:</p>
<p><code>h &lt;- histogram.register(&quot;duration_histogram&quot;, Array(&quot;method&quot;), ExponentialBuckets(0.25,2,5))</code></p>
<p>Finally, we have two variations of <code>time</code>, one that returns the duration and the
result of executing the <code>Task</code> or <code>RIO</code> and another (<code>time_</code>) that only executes the
<code>Task</code> and returns the result, but not the duration. The benefit of <code>time_</code> is
that it uses <code>ZIO.bracket</code> underneath to have stronger guarantees on the
acquisition, use, and release of the timer and the task execution.</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">import</span> zio.<span class="hljs-type">Task</span>
  
  <span class="hljs-keyword">val</span> testHistogramTask: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, (<span class="hljs-type">CollectorRegistry</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">String</span>)] = <span class="hljs-keyword">for</span> {
    h     &lt;- <span class="hljs-type">Histogram</span>(<span class="hljs-string">"task_histogram_timer"</span>, <span class="hljs-type">Array</span>.empty[<span class="hljs-type">String</span>], <span class="hljs-type">DefaultBuckets</span>(<span class="hljs-type">Seq</span>.empty[<span class="hljs-type">Double</span>]))
    (d,s) &lt;- h.time(<span class="hljs-type">Task</span>{<span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">2000</span>); <span class="hljs-string">"Success"</span>})
    r     &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> (r, d, s)

  <span class="hljs-keyword">val</span> testHistogramTask2: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, (<span class="hljs-type">CollectorRegistry</span>, <span class="hljs-type">String</span>)] = <span class="hljs-keyword">for</span> {
    h &lt;- histogram.register(<span class="hljs-string">"task_histogram_timer_"</span>)
    a &lt;- h.time_(<span class="hljs-type">Task</span>{<span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">2000</span>); <span class="hljs-string">"Success"</span>})
    r &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> (r, a)
</code></pre>
<p>Now lets inspect our values by <code>tap</code>ping our <code>RIO</code>. Add <code>with Clock.Live</code>
to the runtime <code>rt</code> before executing the following code.</p>
<pre><code class="hljs css language-scala mdoc:silent">  rt.unsafeRun(testHistogramDuration.tap(r =&gt; write004(r).map(println)))
</code></pre>
<p>Please note there's no reason to use <code>tap</code> here, its just to demonstrate that we
are returning <code>RIO</code>s which means we have at our disposal all its combinators. We
might as well just use</p>
<pre><code class="hljs">  <span class="hljs-keyword">val</span> rhd = rt.unsafe<span class="hljs-constructor">Run(<span class="hljs-params">testHistogramDuration</span>)</span>
  write004(rhd)
</code></pre>
<p>instead or any other way we've seen of observing our <code>CollectorRegistry</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="summary"></a><a href="#summary" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h2>
<p><code>Summary</code> works exactly as <code>Histogram</code> above except a <code>Summary</code> also allows to
pass the list of percentiles we wish to include in our measures: <code>quantiles: List[(Percentile, Tolerance)]</code> where <code>Percentile</code> is a <code>Double</code> value between 0
and 1 that represents the percentile (i.e. 0.5 = median) and <code>Tolerance</code> is a
<code>Double</code> value (also between 0 and 1) that represents the tolerated error. Refer
to the <a href="https://prometheus.io/docs/practices/histograms/#quantiles">Prometheus
Percentile</a>
documentation for more information.</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testSummary: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    s  &lt;- <span class="hljs-type">Summary</span>(<span class="hljs-string">"simple_summary"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"method"</span>), <span class="hljs-type">List</span>((<span class="hljs-number">0.5</span>, <span class="hljs-number">0.05</span>), (<span class="hljs-number">0.9</span>, <span class="hljs-number">0.01</span>)))
    _  &lt;- <span class="hljs-type">RIO</span>.foreach(<span class="hljs-type">List</span>(<span class="hljs-number">10.5</span>, <span class="hljs-number">25.0</span>, <span class="hljs-number">50.7</span>, <span class="hljs-number">57.3</span>, <span class="hljs-number">19.8</span>))(s.observe(_, <span class="hljs-type">Array</span>(<span class="hljs-string">"put"</span>)))
    r  &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> r
</code></pre>
<p>Just like <code>Histogram</code> it has methods <code>time</code> and <code>time_</code> that take a <code>Task</code> or
<code>RIO</code> as input.</p>
<pre><code class="hljs css language-scala mdoc:silent">  <span class="hljs-keyword">val</span> testSummaryTask: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    s &lt;- summary.register(<span class="hljs-string">"task_summary_timer"</span>)
    _ &lt;- s.time(<span class="hljs-type">Task</span>(<span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">2000</span>)))
    r &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> r

  <span class="hljs-keyword">val</span> testSummaryTask2: <span class="hljs-type">RIO</span>[<span class="hljs-type">Registry</span>, <span class="hljs-type">CollectorRegistry</span>] = <span class="hljs-keyword">for</span> {
    s &lt;- summary.register(<span class="hljs-string">"task_summary_timer_"</span>)
    _ &lt;- s.time_(<span class="hljs-type">Task</span>(<span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">2000</span>)))
    r &lt;- getCurrentRegistry()
  } <span class="hljs-keyword">yield</span> r
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="dependency-injection-with-zlayers"></a><a href="#dependency-injection-with-zlayers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dependency Injection with ZLayers</h2>
<p>A common principle in functional programming is to execute the effects <code>at the end of the world</code> in your application. This basically means that you will write
pure functions by wrapping your effectful code in ZIO and you execute them from
your top-most functions, i.e. in <code>main</code> or as close as possible to <code>main</code>.
Unfortunately, this has the effect (pun intended) of creating a tree-like
structure of nested functions.</p>
<p>Let's say, for instance, you have a <code>Router</code> which calls a <code>Service</code> which
calls 2 different functions, <code>MeasuringPoint1</code> and <code>MeasuringPoint2</code> where you
need to count something. If you <code>register</code> the counter in <code>MyRoutes</code> then you
need to pass the counter downstream first to <code>MyService1</code> and then to the MeasuringPoint
functions.</p>
<pre><code class="hljs">MyRoutes<span class="hljs-function">
  -&gt;</span> MyService1<span class="hljs-function"><span class="hljs-params">(counter)</span>
    -&gt;</span> MeasuringPoint1<span class="hljs-function"><span class="hljs-params">(counter)</span>
    -&gt;</span> MeasuringPoint2(counter)
</code></pre>
<p>The deeper such functions are, the more cumbersome this becomes. You could
reduce the number of times you pass the counter by registering it immediately
above where they're needed (in <code>MyService1</code>) but on one hand that means you will
probably end up registering your metrics all over your code (instead of at a
central location) and on the other it will not work if you also need the counter
on, say, a <code>MyService2</code> service.</p>
<p>One way to deal with this is using <code>ZLayer</code> to make your environment <code>R</code> carry
your metrics for you. I'll present two ways to achieve this, each with its own
advantages and drawbacks. The first is to create your own <code>Metrics</code> layer where
you will register the exact metrics you need as private values and then you
simply expose methods to use them in your <code>MeasuringPoints</code> through the Layer:</p>
<pre><code class="hljs css language-scala">  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Env</span> </span>= <span class="hljs-type">Registry</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Exporters</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Console</span>
  <span class="hljs-keyword">val</span> rtLayer = <span class="hljs-type">Runtime</span>.unsafeFromLayer(<span class="hljs-type">Registry</span>.live ++ <span class="hljs-type">Exporters</span>.live ++ <span class="hljs-type">Console</span>.live)

  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Metrics</span> </span>= <span class="hljs-type">Has</span>[<span class="hljs-type">Metrics</span>.<span class="hljs-type">Service</span>]

  <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Metrics</span> </span>{
    <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Service</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRegistry</span></span>(): <span class="hljs-type">Task</span>[<span class="hljs-type">CollectorRegistry</span>]

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inc</span></span>(tags: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Task</span>[<span class="hljs-type">Unit</span>]

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inc</span></span>(amount: <span class="hljs-type">Double</span>, tags: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Task</span>[<span class="hljs-type">Unit</span>]

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">time</span></span>(f: () =&gt; <span class="hljs-type">Unit</span>, tags: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Task</span>[<span class="hljs-type">Double</span>]

    }

    <span class="hljs-keyword">val</span> live: <span class="hljs-type">Layer</span>[<span class="hljs-type">Nothing</span>, <span class="hljs-type">Metrics</span>] = <span class="hljs-type">ZLayer</span>.succeed(<span class="hljs-keyword">new</span> <span class="hljs-type">Service</span> {

      <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> (myCounter, myHistogram) = rtLayer.unsafeRun(
        <span class="hljs-keyword">for</span> {
          c &lt;- counter.register(<span class="hljs-string">"myCounter"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"name"</span>, <span class="hljs-string">"method"</span>))
          h &lt;- histogram.register(<span class="hljs-string">"myHistogram"</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"name"</span>, <span class="hljs-string">"method"</span>))
        } <span class="hljs-keyword">yield</span> (c, h)
      )

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRegistry</span></span>(): <span class="hljs-type">Task</span>[<span class="hljs-type">CollectorRegistry</span>] =
        getCurrentRegistry().provideLayer(<span class="hljs-type">Registry</span>.live)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inc</span></span>(tags: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): zio.<span class="hljs-type">Task</span>[<span class="hljs-type">Unit</span>] =
        inc(<span class="hljs-number">1.0</span>, tags)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inc</span></span>(amount: <span class="hljs-type">Double</span>, tags: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Task</span>[<span class="hljs-type">Unit</span>] =
        myCounter.inc(amount, tags)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">time</span></span>(f: () =&gt; <span class="hljs-type">Unit</span>, tags: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Task</span>[<span class="hljs-type">Double</span>] =
        myHistogram.time(f, tags)
    })

  }
</code></pre>
<p>And then we can use it so:</p>
<pre><code class="hljs css language-scala">  <span class="hljs-keyword">val</span> exporterTest: <span class="hljs-type">RIO</span>[
    <span class="hljs-type">Metrics</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Exporters</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Console</span>,
    <span class="hljs-type">HTTPServer</span>
  ] =
    <span class="hljs-keyword">for</span> {
      m  &lt;- <span class="hljs-type">RIO</span>.environment[<span class="hljs-type">Metrics</span>]
      _  &lt;- putStrLn(<span class="hljs-string">"Exporters"</span>)
      r  &lt;- m.get.getRegistry()
      _  &lt;- initializeDefaultExports(r)
      hs &lt;- http(r, <span class="hljs-number">9090</span>)
      _  &lt;- m.get.inc(<span class="hljs-type">Array</span>(<span class="hljs-string">"RequestCounter"</span>, <span class="hljs-string">"get"</span>))
      _  &lt;- m.get.inc(<span class="hljs-type">Array</span>(<span class="hljs-string">"RequestCounter"</span>, <span class="hljs-string">"post"</span>))
      _  &lt;- m.get.inc(<span class="hljs-number">2.0</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"LoginCounter"</span>, <span class="hljs-string">"login"</span>))
      _  &lt;- m.get.time(() =&gt; <span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">2000</span>), <span class="hljs-type">Array</span>(<span class="hljs-string">"histogram"</span>, <span class="hljs-string">"get"</span>))
      s  &lt;- write004(r)
      _  &lt;- putStrLn(s)
    } <span class="hljs-keyword">yield</span> hs

  <span class="hljs-keyword">val</span> programL = exporterTest &gt;&gt;= (server =&gt; putStrLn(<span class="hljs-string">s"Server port: <span class="hljs-subst">${server.getPort()}</span>"</span>))

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> =
    rtLayer.unsafeRun(programL.provideSomeLayer[<span class="hljs-type">Env</span>](<span class="hljs-type">Metrics</span>.live))
</code></pre>
<p>The key of this approach is that even if you register only one counter, you can
in practice have as many counters (or any other metric) as you need by
distinguishing them using the <code>name</code> tag. You can have as many different
counters as combination of tags you can devise for your app. Your
<code>MeasuringPoints</code> can be as nested as they need to be, you just need to declare
<code>Metrics</code> as part of your environment in the function that will actually get to
use it.</p>
<p>The main drawback, as far as I can tell, is that you need that extra call to
<code>unsafeRun</code> in order to extract and use the metrics themselves. If you don't,
then every call to <code>inc</code> or <code>time</code> would attemp to re-register the metric which
results in an Exception. This is because things wrapped up in <code>ZIO</code>s are
descriptions of a program so flatmapping or folding on them causes them to
start their execution flow from the beginning.</p>
<p>Although the ideal is to call <code>unsafeRun</code> only once in your App, this is only an
ideal and calling it a second (or even third) time is OK as long as you do not
abuse its usage.</p>
<p>You can, however, eliminate this extra <code>unsafeRun</code> by registering your <code>counter</code>
and <code>histogram</code> during startup and pass them as inputs to your <code>ZLayer</code> using
<code>fromFunction</code>:</p>
<pre><code class="hljs css language-scala">    <span class="hljs-keyword">val</span> receiver: <span class="hljs-type">ZLayer</span>[(<span class="hljs-type">Counter</span>, <span class="hljs-type">Histogram</span>), <span class="hljs-type">Nothing</span>, <span class="hljs-type">Metrics</span>] = <span class="hljs-type">ZLayer</span>.fromFunction[(<span class="hljs-type">Counter</span>, <span class="hljs-type">Histogram</span>), <span class="hljs-type">Metrics</span>.<span class="hljs-type">Service</span>]( minsts =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">Service</span> {

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRegistry</span></span>(): <span class="hljs-type">Task</span>[<span class="hljs-type">CollectorRegistry</span>] =
        getCurrentRegistry().provideLayer(<span class="hljs-type">Registry</span>.live)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inc</span></span>(tags: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): zio.<span class="hljs-type">Task</span>[<span class="hljs-type">Unit</span>] =
        inc(<span class="hljs-number">1.0</span>, tags)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inc</span></span>(amount: <span class="hljs-type">Double</span>, tags: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Task</span>[<span class="hljs-type">Unit</span>] =
        minsts._1.inc(amount, tags)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">time</span></span>(f: () =&gt; <span class="hljs-type">Unit</span>, tags: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Task</span>[<span class="hljs-type">Double</span>] =
        minsts._2.time(f, tags)
    })
</code></pre>
<p>The second approach is somewhat more generic and doesn't need extra calls to
<code>unsafeRun</code> but it requires the use of <code>PartialFunction</code>s and keeping a private
<code>Map</code> inside our custom Layer, here called <code>MetricsMap</code>:</p>
<pre><code class="hljs css language-scala">  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MetricMap</span> </span>= <span class="hljs-type">Has</span>[<span class="hljs-type">MetricMap</span>.<span class="hljs-type">Service</span>]

  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InvalidMetric</span>(<span class="hljs-params">msg: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>

  <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MetricMap</span> </span>{
    <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Service</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRegistry</span></span>(): <span class="hljs-type">Task</span>[<span class="hljs-type">CollectorRegistry</span>]

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span></span>(name: <span class="hljs-type">String</span>, metric: <span class="hljs-type">Metric</span>): <span class="hljs-type">Task</span>[<span class="hljs-type">Unit</span>]

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHistogram</span></span>(name: <span class="hljs-type">String</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">InvalidMetric</span>, <span class="hljs-type">Histogram</span>]

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getCounter</span></span>(name: <span class="hljs-type">String</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">InvalidMetric</span>, <span class="hljs-type">Counter</span>]
    }

    <span class="hljs-keyword">val</span> live: <span class="hljs-type">Layer</span>[<span class="hljs-type">Nothing</span>, <span class="hljs-type">MetricMap</span>] = <span class="hljs-type">ZLayer</span>.succeed(<span class="hljs-keyword">new</span> <span class="hljs-type">Service</span> {

      <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> metricsMap: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Metric</span>] = <span class="hljs-type">Map</span>.empty[<span class="hljs-type">String</span>, <span class="hljs-type">Metric</span>]

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRegistry</span></span>(): <span class="hljs-type">Task</span>[<span class="hljs-type">CollectorRegistry</span>] =
        getCurrentRegistry().provideLayer(<span class="hljs-type">Registry</span>.live)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span></span>(key: <span class="hljs-type">String</span>, metric: <span class="hljs-type">Metric</span>): <span class="hljs-type">Task</span>[<span class="hljs-type">Unit</span>] =
        <span class="hljs-type">Task</span>(
          <span class="hljs-keyword">this</span>.metricsMap =
            <span class="hljs-keyword">if</span> (metricsMap.contains(key))
              metricsMap.updated(key, metric)
            <span class="hljs-keyword">else</span>
              metricsMap + (key -&gt; metric)
        ).unit

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHistogram</span></span>(name: <span class="hljs-type">String</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">InvalidMetric</span>, <span class="hljs-type">Histogram</span>] =
        metricsMap(name) <span class="hljs-keyword">match</span> {
          <span class="hljs-keyword">case</span> h @ <span class="hljs-type">Histogram</span>(_) =&gt; <span class="hljs-type">IO</span>.succeed(h)
          <span class="hljs-keyword">case</span> _                =&gt; <span class="hljs-type">IO</span>.fail(<span class="hljs-type">InvalidMetric</span>(<span class="hljs-string">"Metric is not a Histogram or doesn't exists!"</span>))
        }

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getCounter</span></span>(name: <span class="hljs-type">String</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">InvalidMetric</span>, <span class="hljs-type">Counter</span>] =
        metricsMap(name) <span class="hljs-keyword">match</span> {
          <span class="hljs-keyword">case</span> c @ <span class="hljs-type">Counter</span>(_) =&gt; <span class="hljs-type">IO</span>.succeed(c)
          <span class="hljs-keyword">case</span> _              =&gt; <span class="hljs-type">IO</span>.fail(<span class="hljs-type">InvalidMetric</span>(<span class="hljs-string">"Metric is not a Counter or doesn't exists!"</span>))
        }
    })
  }
</code></pre>
<p>Simply put: the <code>MetricsMap</code> layer exposes methods to <code>get</code> and <code>put</code> metrics
inside its private <code>Map</code>, overwriting the existing metric if the <code>key</code> is
already registered. You only write to this <code>Map</code> when registering a metric NOT
when actually using it, so the requirement for safe-concurrency are quite low.</p>
<p>This technique aloows you to register all your metrics in one place:</p>
<pre><code class="hljs css language-scala">  <span class="hljs-keyword">val</span> startup: <span class="hljs-type">RIO</span>[
    <span class="hljs-type">MetricMap</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Registry</span>,
    <span class="hljs-type">Unit</span>
  ] =
    <span class="hljs-keyword">for</span> {
      m     &lt;- <span class="hljs-type">RIO</span>.environment[<span class="hljs-type">MetricMap</span>]
      name  = <span class="hljs-string">"ExportersTest"</span>
      c     &lt;- <span class="hljs-type">Counter</span>(name, <span class="hljs-type">Array</span>(<span class="hljs-string">"exporter"</span>))
      hname = <span class="hljs-string">"export_histogram"</span>
      h &lt;- histogram
            .register(hname, <span class="hljs-type">Array</span>(<span class="hljs-string">"exporter"</span>, <span class="hljs-string">"method"</span>))
            .provideLayer(<span class="hljs-type">Registry</span>.live)
      _ &lt;- m.get.put(name, c)
      _ &lt;- m.get.put(hname, h)
    } <span class="hljs-keyword">yield</span> ()
</code></pre>
<p>and then usinig them downstream wherever you need:</p>
<pre><code class="hljs css language-scala">  <span class="hljs-keyword">val</span> rtMM = <span class="hljs-type">Runtime</span>.unsafeFromLayer(<span class="hljs-type">MetricMap</span>.live ++ <span class="hljs-type">Registry</span>.live ++ <span class="hljs-type">Exporters</span>.live ++ <span class="hljs-type">Console</span>.live)

  <span class="hljs-keyword">val</span> exporterTest: <span class="hljs-type">RIO</span>[
    <span class="hljs-type">MetricMap</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Exporters</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Console</span>,
    <span class="hljs-type">HTTPServer</span>
  ] =
    <span class="hljs-keyword">for</span> {
      m  &lt;- <span class="hljs-type">RIO</span>.environment[<span class="hljs-type">MetricMap</span>]
      _  &lt;- putStrLn(<span class="hljs-string">"Exporters"</span>)
      r  &lt;- m.get.getRegistry()
      _  &lt;- initializeDefaultExports(r)
      hs &lt;- http(r, <span class="hljs-number">9090</span>)
      c  &lt;- m.get.getCounter(<span class="hljs-string">"ExportersTest"</span>)
      _  &lt;- c.inc(<span class="hljs-type">Array</span>(<span class="hljs-string">"counter"</span>))
      _  &lt;- c.inc(<span class="hljs-number">2.0</span>, <span class="hljs-type">Array</span>(<span class="hljs-string">"counter"</span>))
      h  &lt;- m.get.getHistogram(<span class="hljs-string">"export_histogram"</span>)
      _  &lt;- h.time(() =&gt; <span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">2000</span>), <span class="hljs-type">Array</span>(<span class="hljs-string">"histogram"</span>, <span class="hljs-string">"get"</span>))
      s  &lt;- write004(r)
      _  &lt;- putStrLn(s)
    } <span class="hljs-keyword">yield</span> hs

  <span class="hljs-keyword">val</span> programMM = startup *&gt; exporterTest &gt;&gt;= (server =&gt; putStrLn(<span class="hljs-string">s"Server port: <span class="hljs-subst">${server.getPort()}</span>"</span>))

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> =
    rt.unsafeRunMM(programMM)
</code></pre>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 1/4/2022 by toxicafunk</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#registry">Registry</a><ul class="toc-headings"><li><a href="#pass-the-collectorregistry-explicitly">Pass the CollectorRegistry explicitly</a></li></ul></li><li><a href="#counter">Counter</a></li><li><a href="#helpers">Helpers</a></li><li><a href="#gauge">Gauge</a></li><li><a href="#exporters">Exporters</a></li><li><a href="#histogram">Histogram</a></li><li><a href="#summary">Summary</a></li><li><a href="#dependency-injection-with-zlayers">Dependency Injection with ZLayers</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section><div><div class="gitter-open-chat-button">Open Chat</div><script type="text/javascript">
        ((window.gitter = {}).chat = {}).options = {
          showChatByDefault: false,
          activationElement: '.gitter-open-chat-button',
          room: 'zio/zio-metrics'
        };
      </script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async="" defer=""></script></div></section><section class="sitemap"><a href="/zio-metrics/" class="nav-home"><img src="/zio-metrics/img/sidebar_brand2x.png" alt="ZIO Metrics"/></a><div><h5>GitHub</h5><a class="github-button" href="https://github.com/zio/zio-metrics" data-icon="octicon-star" data-count-href="/zio/zio-metrics/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="/zio-metrics/img/discord.png" width="120" alt="discord"/></a></div><div><h5>Additional resources</h5><a href="https://javadoc.io/doc/dev.zio/zio_2.12/">Scaladoc of ZIO</a></div></section><section class="copyright">Copyright © 2022 ZIO Maintainers</section></footer></div></body></html>